#!/usr/bin/env python3
"""
Lightweight Flask API for serving river data to ESP32/IoT devices
Reads from the gauges.json file generated by usgs_multi_alert.py
Also serves the static HTML dashboard on the main page
"""

from flask import Flask, jsonify, request, send_from_directory, send_file
import json
import os
from datetime import datetime

# Optional CORS support
try:
    from flask_cors import CORS
    cors_available = True
except ImportError:
    cors_available = False
    print("Warning: flask-cors not installed. CORS will not be enabled.")

app = Flask(__name__)

if cors_available:
    CORS(app)  # Enable CORS for all routes

# Path to static site files
SITE_DIR = os.environ.get('SITE_DIR', '/site')

# Path to the generated gauges.json file
# Try multiple paths for local dev vs container
GAUGES_JSON_PATHS = [
    "/site/gauges.json",                                           # Container path
    "/chanslor/mdc/YOUTUBE/chanslor-usgs-river-levels/docker/usgs-site/gauges.json",  # Local dev path
    "usgs-site/gauges.json"                                        # Relative path
]

def get_gauges_json_path():
    """Find the first existing gauges.json file"""
    for path in GAUGES_JSON_PATHS:
        if os.path.exists(path):
            return path
    return None

GAUGES_JSON_PATH = get_gauges_json_path()

def load_gauges_data():
    """Load and parse the gauges.json file"""
    try:
        if not os.path.exists(GAUGES_JSON_PATH):
            return None

        with open(GAUGES_JSON_PATH, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"Error loading gauges data: {e}")
        return None

def format_for_display(site_data):
    """
    Format site data for ESP32 OLED display
    Returns a compact format optimized for the 5-line display
    """
    name = site_data.get('name', 'Unknown')
    cfs = site_data.get('cfs')
    stage_ft = site_data.get('stage_ft')
    trend = site_data.get('trend_8h', 'unknown')

    # QPF data (precipitation forecast)
    qpf = site_data.get('qpf', {})
    qpf_dates = sorted(qpf.keys())
    qpf_today = qpf.get(qpf_dates[0], 0.0) if len(qpf_dates) > 0 else 0.0
    qpf_tomorrow = qpf.get(qpf_dates[1], 0.0) if len(qpf_dates) > 1 else 0.0
    qpf_day3 = qpf.get(qpf_dates[2], 0.0) if len(qpf_dates) > 2 else 0.0

    # Weather observations
    obs = site_data.get('obs', {})
    temp_f = obs.get('temp_f')
    wind_mph = obs.get('wind_mph', 0.0)
    wind_dir = obs.get('wind_dir', 'N')

    # Determine flow status
    if cfs is not None:
        threshold_cfs = site_data.get('threshold_cfs')
        if threshold_cfs and cfs >= threshold_cfs:
            flow_status = f">= {cfs:.0f} cfs"
        else:
            flow_status = f"{cfs:.0f} cfs"
    else:
        flow_status = "N/A"

    # Trend arrow
    trend_arrow = "->"
    if trend == "rising":
        trend_arrow = "^"
    elif trend == "falling":
        trend_arrow = "v"

    return {
        "site_id": site_data.get('site'),
        "name": name,
        "flow": flow_status,
        "trend": f"{trend_arrow} {trend}",
        "stage_ft": stage_ft,
        "qpf": {
            "today": qpf_today,
            "tomorrow": qpf_tomorrow,
            "day3": qpf_day3
        },
        "weather": {
            "temp_f": temp_f,
            "wind_mph": wind_mph,
            "wind_dir": wind_dir
        },
        "timestamp": site_data.get('ts_iso'),
        "in_range": site_data.get('in_range', False),

        # Formatted strings for ESP32 display (5 lines)
        "display_lines": [
            f"{name}",
            f"{flow_status} {trend_arrow} {trend}",
            f"QPF Today: {qpf_today:.2f}\"",
            f"Tom:{qpf_tomorrow:.2f}\" Day3:{qpf_day3:.2f}\"",
            f"Max:{temp_f:.0f}F Wind:{wind_mph:.1f} {wind_dir}" if temp_f else "Weather: N/A"
        ]
    }

@app.route('/api/health', methods=['GET'])
def health():
    """Health check endpoint"""
    return jsonify({
        "status": "ok",
        "timestamp": datetime.utcnow().isoformat() + "Z"
    })

@app.route('/api/river-levels', methods=['GET'])
def get_all_river_levels():
    """
    Get all river levels
    Returns data for all monitored sites
    """
    data = load_gauges_data()

    if not data:
        return jsonify({
            "error": "Data not available",
            "message": "Unable to load river data. Background worker may not be running."
        }), 503

    sites = data.get('sites', [])
    formatted_sites = [format_for_display(site) for site in sites]

    return jsonify({
        "generated_at": data.get('generated_at'),
        "site_count": len(formatted_sites),
        "sites": formatted_sites
    })

@app.route('/api/river-levels/<site_id>', methods=['GET'])
def get_river_level(site_id):
    """
    Get data for a specific site
    Example: /api/river-levels/02399200 (Little River)
    """
    data = load_gauges_data()

    if not data:
        return jsonify({
            "error": "Data not available",
            "message": "Unable to load river data"
        }), 503

    # Find the requested site
    sites = data.get('sites', [])
    site_data = next((s for s in sites if s.get('site') == site_id), None)

    if not site_data:
        return jsonify({
            "error": "Site not found",
            "message": f"No data available for site {site_id}",
            "available_sites": [s.get('site') for s in sites]
        }), 404

    return jsonify(format_for_display(site_data))

@app.route('/api/river-levels/name/<name>', methods=['GET'])
def get_river_level_by_name(name):
    """
    Get data for a specific site by name (case-insensitive partial match)
    Example: /api/river-levels/name/little (matches "Little River")
    """
    data = load_gauges_data()

    if not data:
        return jsonify({
            "error": "Data not available"
        }), 503

    # Find site by name (case-insensitive partial match)
    sites = data.get('sites', [])
    name_lower = name.lower()
    site_data = next(
        (s for s in sites if name_lower in s.get('name', '').lower()),
        None
    )

    if not site_data:
        return jsonify({
            "error": "Site not found",
            "message": f"No site matching '{name}'",
            "available_sites": [{"id": s.get('site'), "name": s.get('name')} for s in sites]
        }), 404

    return jsonify(format_for_display(site_data))

@app.route('/')
def index():
    """Serve the main dashboard HTML"""
    index_path = os.path.join(SITE_DIR, 'index.html')
    if os.path.exists(index_path):
        return send_file(index_path)
    else:
        return "<h1>River Monitor Starting...</h1><p>Please wait while initial data loads...</p>", 503

@app.route('/gauges.json')
def gauges_json():
    """Serve the gauges data JSON"""
    json_path = os.path.join(SITE_DIR, 'gauges.json')
    if os.path.exists(json_path):
        return send_file(json_path, mimetype='application/json')
    else:
        return jsonify({"loading": True}), 503

@app.route('/details/<path:filename>')
def details(filename):
    """Serve detail pages"""
    details_dir = os.path.join(SITE_DIR, 'details')
    return send_from_directory(details_dir, filename)

@app.route('/api')
def api_info():
    """API documentation endpoint"""
    return jsonify({
        "name": "USGS River Levels API",
        "version": "1.0",
        "dashboard": "/",
        "endpoints": {
            "health": "/api/health",
            "all_rivers": "/api/river-levels",
            "by_site_id": "/api/river-levels/{site_id}",
            "by_name": "/api/river-levels/name/{name}"
        },
        "examples": {
            "little_river": "/api/river-levels/02399200",
            "little_river_by_name": "/api/river-levels/name/little",
            "locust_fork": "/api/river-levels/02455000"
        }
    })

if __name__ == '__main__':
    # Run on port 8080 to match the existing configuration (or PORT env var)
    port = int(os.environ.get('PORT', 8080))
    app.run(host='0.0.0.0', port=port, debug=False)
